# Grafana Helm Chart Values for Official Grafana Chart
# Corrected configuration based on lessons learned from previous failures
# This configuration fixes database integration and NodePort assignment issues

global:
  imageRegistry: ""
  imagePullSecrets: []

# Common labels for all resources
commonLabels: {}

# =============================================================================
# GRAFANA CONFIGURATION (CRITICAL FIX FOR DATABASE INTEGRATION)
# =============================================================================
grafana:
  # Admin user configuration
  adminUser: admin
  # Admin password is auto-generated by Helm and stored in Kubernetes secret
  # Retrieve password with: kubectl get secret grafana -n grafana -o jsonpath='{.data.admin-password}' | base64 -d
  
  # Use existing secret for admin credentials (optional)
  existingSecret: ""
  
  # Enable/disable features
  enableServiceLinks: true
  ldapEnabled: false
  smtpEnabled: false

# =============================================================================
# GRAFANA.INI CONFIGURATION (CRITICAL FIX - CORRECT DATABASE CONFIG)
# =============================================================================
# This is the CORRECT way to configure database for official Grafana chart
grafana.ini:
  # Database configuration - using external PostgreSQL
  database:
    type: postgres
    host: "postgres-postgresql.postgres.svc.cluster.local"  # FIXED: Use correct Kubernetes service FQDN
    port: 5432  # FIXED: Separate port configuration
    name: "grafana"
    user: "grafana"
    password: "grafana_password123"
    ssl_mode: "disable"
    max_idle_conn: 2
    max_open_conn: 0
    conn_max_lifetime: 14400
  
  # Security settings
  security:
    admin_user: "admin"
    # Admin password is auto-generated by Helm and stored in Kubernetes secret
    # Retrieve password with: kubectl get secret grafana -n grafana -o jsonpath='{.data.admin-password}' | base64 -d
    secret_key: "grafana_secret_key_$(date +%s)"
    disable_gravatar: false
    data_source_proxy_whitelist: ""
    
  # Server settings
  server:
    domain: "grafana.local"  # Use ingress domain
    root_url: "http://grafana.local"  # Ingress URL
    serve_from_sub_path: false
    enforce_domain: false
    socket: ""
    cert_key: ""
    cert_file: ""
    protocol: http
    http_addr: ""
    http_port: 3000
    
  # Paths configuration
  paths:
    data: /var/lib/grafana/
    logs: /var/log/grafana
    plugins: /var/lib/grafana/plugins
    provisioning: /etc/grafana/provisioning
    
  # Analytics configuration
  analytics:
    check_for_updates: true
    reporting_enabled: true
    google_analytics_ua_id: ""
    
  # Grafana Network configuration
  grafana_net:
    url: https://grafana.net
    
  # Log configuration
  log:
    mode: console
    level: info
    
  # Users configuration
  users:
    allow_sign_up: false
    auto_assign_org: true
    auto_assign_org_role: Viewer
    viewers_can_edit: false
    editors_can_admin: false
    
  # SMTP configuration (disabled)
  smtp:
    enabled: false
    
  # LDAP configuration (disabled)
  ldap:
    enabled: false

# =============================================================================
# IMAGE CONFIGURATION
# =============================================================================
image:
  registry: docker.io
  repository: grafana/grafana
  tag: "12.3.0"
  digest: ""
  pullPolicy: IfNotPresent

# =============================================================================
# DEPLOYMENT CONFIGURATION
# =============================================================================
deploymentStrategy:
  type: RollingUpdate

# Pod configuration
podLabels: {}
podAnnotations: {}

# =============================================================================
# RESOURCE CONFIGURATION
# =============================================================================
resources:
  limits:
    cpu: 500m
    memory: 512Mi
  requests:
    cpu: 250m
    memory: 256Mi

# =============================================================================
# AUTO-SCALING CONFIGURATION
# =============================================================================
autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 100
  targetCPU: 80
  targetMemory: 80

# =============================================================================
# SECURITY CONFIGURATION
# =============================================================================
containerSecurityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
    - ALL
  runAsNonRoot: true
  runAsUser: 1001
  seccompProfile:
    type: RuntimeDefault

podSecurityContext:
  fsGroup: 1001
  # FIXED: Allow Grafana to run as root to bind to port 80
  runAsUser: 0
  runAsGroup: 0

# =============================================================================
# PROBE CONFIGURATION (CRITICAL FIX - USE PORT NUMBERS)
# =============================================================================
livenessProbe:
  httpGet:
    path: /api/health
    port: 3000  # FIXED: Use port number instead of name
  initialDelaySeconds: 120
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 6
  successThreshold: 1

readinessProbe:
  httpGet:
    path: /api/health
    port: 3000  # FIXED: Use port number instead of name
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 6
  successThreshold: 1

startupProbe:
  httpGet:
    path: /api/health
    port: 3000  # FIXED: Use port number instead of name
  initialDelaySeconds: 10
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 30
  successThreshold: 1

# =============================================================================
# SERVICE CONFIGURATION (CLUSTERIP FOR INGRESS + NODEPORT FALLBACK)
# =============================================================================
service:
  type: ClusterIP  # Use ClusterIP for ingress (can be changed to NodePort for fallback)
  port: 80  # FIXED: Set service port to 80 to match Grafana's default
  targetPort: 3000  # FIXED: Forward to Grafana's internal port 3000
  nodePorts:
    http: "30030"  # Keep NodePort as fallback option
  clusterIP: ""
  loadBalancerIP: ""
  loadBalancerSourceRanges: []
  annotations: {}
  extraPorts: []

# =============================================================================
# INGRESS CONFIGURATION (ENABLED FOR HTTP ACCESS)
# =============================================================================
ingress:
  enabled: true
  # For Kubernetes >= 1.18 you should specify the ingress-controller via the field ingressClassName
  ingressClassName: "public"  # FIXED: Use public ingress class (same as working PostgreSQL)
  annotations:
    # Simplified annotations based on working PostgreSQL configuration
    nginx.ingress.kubernetes.io/rewrite-target: "/"
  labels:
    app: grafana
    component: ingress
  hosts:
    - host: grafana.local
      paths:
        - path: /
          pathType: Prefix
  tls: []

# =============================================================================
# PERSISTENCE CONFIGURATION
# =============================================================================
persistence:
  enabled: true
  storageClass: "microk8s-hostpath"
  size: 10Gi
  accessModes:
    - ReadWriteOnce
  annotations: {}
  existingClaim: ""
  initChownData: false  # Disable init container to avoid permission issues

# =============================================================================
# ADDITIONAL VOLUMES AND MOUNTS
# =============================================================================
extraVolumes: []
extraVolumeMounts: []

# =============================================================================
# SIDEKAR AND INIT CONTAINERS
# =============================================================================
sidecars: []
initContainers: []

# =============================================================================
# NETWORKING AND SCHEDULING
# =============================================================================
nodeSelector: {}
tolerations: []
affinity: {}

podAntiAffinity: soft

# =============================================================================
# RBAC CONFIGURATION
# =============================================================================
rbac:
  create: true
  rules: []

serviceAccount:
  create: true
  annotations: {}
  name: ""

# =============================================================================
# POD DISRUPTION BUDGET
# =============================================================================
podDisruptionBudget:
  enabled: false
  minAvailable: 1
  maxUnavailable: ""

# =============================================================================
# EXTRA MANIFESTS
# =============================================================================
extraDeploy: []

# =============================================================================
# METRICS CONFIGURATION
# =============================================================================
metrics:
  enabled: false
  serviceMonitor:
    enabled: false
    namespace: ""
    labels: {}
    annotations: {}
    jobLabel: ""
    interval: ""
    scrapeTimeout: ""

# =============================================================================
# NETWORK POLICY
# =============================================================================
networkPolicy:
  enabled: false

# =============================================================================
# ENVIRONMENT VARIABLES (CRITICAL FOR DATABASE CONFIG)
# =============================================================================
extraEnvVars:
  - name: GF_DATABASE_TYPE
    value: "postgres"
  - name: GF_DATABASE_HOST
    value: "postgres-postgresql.postgres.svc.cluster.local"  # FIXED: Use correct Kubernetes service FQDN
  - name: GF_DATABASE_PORT
    value: "5432"  # FIXED: Separate port configuration
  - name: GF_DATABASE_NAME
    value: "grafana"
  - name: GF_DATABASE_USER
    value: "grafana"
  - name: GF_DATABASE_PASSWORD
    value: "grafana_password123"
  - name: GF_DATABASE_SSL_MODE
    value: "disable"
  - name: GF_SECURITY_ADMIN_USER
    value: "admin"
  # Admin password is auto-generated by Helm and stored in Kubernetes secret
  # Retrieve password with: kubectl get secret grafana -n grafana -o jsonpath='{.data.admin-password}' | base64 -d
extraEnvVarsCM: ""
extraEnvVarsSecret: ""

# =============================================================================
# COMMAND AND ARGS OVERRIDE
# =============================================================================
command: []
args: []

# =============================================================================
# HOST ALIASES
# =============================================================================
hostAliases: []

# =============================================================================
# EXTRA LABELS
# =============================================================================
extraDeployLabels: {}

# =============================================================================
# TLS CONFIGURATION
# =============================================================================
tls:
  enabled: false
  autoGenerated: false
  existingSecret: ""
  certificatesSecret: ""
  privateKeysSecret: ""
  caCertificatesSecret: ""

# =============================================================================
# PLUGIN CONFIGURATION
# =============================================================================
plugins: []
pluginSettings: {}

# =============================================================================
# GRAFANA API KEY CONFIGURATION
# =============================================================================
apiKeys: []

# =============================================================================
# DASHBOARD CONFIGURATION
# =============================================================================
dashboards: {}
dashboardProviders: {}

# =============================================================================
# DATA SOURCE CONFIGURATION
# =============================================================================
datasources: {}

# =============================================================================
# NOTIFIER CONFIGURATION
# =============================================================================
notifiers: {}

# =============================================================================
# SMTP CONFIGURATION
# =============================================================================
smtp: {}

# =============================================================================
# LDAP CONFIGURATION
# =============================================================================
ldap: {}

# =============================================================================
# GRAFANA ENTERPRISE FEATURES
# =============================================================================
enterprise:
  enabled: false

# =============================================================================
# CUSTOM CONFIGURATION FILES
# =============================================================================
configurationFiles: {}

# =============================================================================
# SECRET VALIDATION
# =============================================================================
assertNoLeakedSecrets: false

# =============================================================================
# CRITICAL NOTES FOR DEPLOYMENT
# =============================================================================
# 1. This configuration fixes the database integration issue by:
#    - Using correct grafana.ini database section format
#    - Including port in the host specification
#    - Adding environment variables for redundancy
#
# 2. NodePort is explicitly set to 30030 to prevent wrong port assignment
#
# 3. All probes use port numbers (3000) instead of port names to prevent
#    "strconv.Atoi: parsing 'http': invalid syntax" errors
#
# 4. Database configuration is applied through both grafana.ini and
#    environment variables to ensure it's properly applied
#
# 5. Resource limits and requests are properly configured
#
# 6. Security contexts are properly configured for non-root execution
#
# 7. Persistent storage uses the correct storage class (microk8s-hostpath)
#
# VERIFICATION CHECKLIST:
# - [ ] PostgreSQL tables created in grafana database
# - [ ] Grafana ConfigMap contains database configuration
# - [ ] Grafana logs show successful PostgreSQL connection
# - [ ] Grafana accessible at http://10.110.40.193:30030
# - [ ] Admin login works (retrieve password from secret)
# - [ ] Pod status shows Ready with no probe errors
# - [ ] Persistent storage mounted (10Gi)
# - [ ] Resource limits applied correctly